
<!doctype html>
<html lang="en">
	<head>
	    <meta charset="utf-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
	        
	    <title>Droplet Demo</title>

	    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
	    <script>
			/*
			--------------------------------------------------------------------
			Puck.js BLE Interface library
			                    Copyright 2016 Gordon Williams (gw@pur3.co.uk)
			--------------------------------------------------------------------
			This Source Code Form is subject to the terms of the Mozilla Public
			License, v. 2.0. If a copy of the MPL was not distributed with this
			file, You can obtain one at http://mozilla.org/MPL/2.0/.
			--------------------------------------------------------------------
			This creates a 'Puck' object that can be used from the Web Browser.

			Simple usage:

			Puck.write("LED1.set()\n")

			Execute expression and return the result:

			Puck.eval("BTN.read()", function(d) {
			  alert(d);
			});

			Or write and wait for a result - this will return all characters,
			including echo and linefeed from the REPL so you may want to send
			`echo(0)` and use `console.log` when doing this.

			Puck.write("1+2\n", function(d) {
			  alert(d);
			});

			Or more advanced usage with control of the connection
			- allows multiple connections

			Puck.connect(function(connection) {
			  if (!connection) throw "Error!";
			  connection.on('data', function(d) { ... });
			  connection.on('close', function() { ... });
			  connection.write("1+2\n", function() {
			    connection.close();
			  });
			});

			*/
			var Puck = (function() {
			  if (typeof navigator == "undefined") return; // not running in a web browser

			  var NORDIC_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
			  var NORDIC_TX = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
			  var NORDIC_RX = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
			  var CHUNKSIZE = 16;

			  function log(s) {
			      if (puck.log) puck.log(s);
			  }

			  function ab2str(buf) {
			      return String.fromCharCode.apply(null, new Uint8Array(buf));
			  }

			  function str2ab(str) {
			      var buf = new ArrayBuffer(str.length);
			      var bufView = new Uint8Array(buf);
			      for (var i = 0, strLen = str.length; i < strLen; i++) {
			          bufView[i] = str.charCodeAt(i);
			      }
			      return buf;
			  }


			  function connect(callback) {
			      if (!navigator.bluetooth) {
			          window.alert("Web Bluetooth isn't enabled in your browser!");
			          return;
			      }

			      var connection = {
			          on: function(evt, cb) {
			              this["on" + evt] = cb;
			          },
			          emit: function(evt, data) {
			              if (this["on" + evt]) this["on" + evt](data);
			          },
			          isOpen: false,
			          isOpening: true,
			          txInProgress: false
			      };
			      var btServer = undefined;
			      var btService;
			      var connectionDisconnectCallback;
			      var txCharacteristic;
			      var rxCharacteristic;
			      var txDataQueue = [];

			      connection.close = function() {
			          connection.isOpening = false;
			          if (connection.isOpen) {
			              connection.isOpen = false;
			              connection.emit('close');
			          } else {
			              if (callback) callback(null);
			          }
			          if (btServer) {
			              btServer.disconnect();
			              btServer = undefined;
			              txCharacteristic = undefined;
			              rxCharacteristic = undefined;
			          }
			      };

			      connection.write = function(data, callback) {
			          if (data) txDataQueue.push({
			              data: data,
			              callback: callback
			          });
			          if (connection.isOpen && !connection.txInProgress) writeChunk();

			          function writeChunk() {
			              var chunk;
			              if (!txDataQueue.length) return;
			              var txItem = txDataQueue[0];
			              if (txItem.data.length <= CHUNKSIZE) {
			                  chunk = txItem.data;
			                  txItem.data = undefined;
			              } else {
			                  chunk = txItem.data.substr(0, CHUNKSIZE);
			                  txItem.data = txItem.data.substr(CHUNKSIZE);
			              }
			              connection.txInProgress = true;
			              log("BT> Sending " + JSON.stringify(chunk));
			              txCharacteristic.writeValue(str2ab(chunk)).then(function() {
			                  log("BT> Sent");
			                  if (!txItem.data) {
			                      txDataQueue.shift(); // remove this element
			                      if (txItem.callback) txItem.callback();
			                  }
			                  connection.txInProgress = false;
			                  writeChunk();
			              }).
			              catch (function(error) {
			                  log('BT> SEND ERROR: ' + error);
			                  txDataQueue = [];
			                  connection.close();
			              });
			          }
			      };

			      navigator.bluetooth.requestDevice({
			          filters: [{
			              namePrefix: 'Puck.js'
			          }, {
			              namePrefix: 'Espruino'
			          }, {
			              services: [NORDIC_SERVICE]
			          }],
			          optionalServices: [NORDIC_SERVICE]
			      }).then(function(device) {
			          log('BT>  Device Name:       ' + device.name);
			          log('BT>  Device ID:         ' + device.id);
			          // Was deprecated: Should use getPrimaryServices for this in future
			          //log('BT>  Device UUIDs:      ' + device.uuids.join('\n' + ' '.repeat(21)));
			          device.addEventListener('gattserverdisconnected', function() {
			              log("BT> Disconnected (gattserverdisconnected)");
			              connection.close();
			          });
			          return device.gatt.connect();
			      }).then(function(server) {
			          log("BT> Connected");
			          btServer = server;
			          return server.getPrimaryService(NORDIC_SERVICE);
			      }).then(function(service) {
			          log("BT> Got service");
			          btService = service;
			          return btService.getCharacteristic(NORDIC_RX);
			      }).then(function(characteristic) {
			          rxCharacteristic = characteristic;
			          log("BT> RX characteristic:" + JSON.stringify(rxCharacteristic));
			          rxCharacteristic.addEventListener('characteristicvaluechanged', function(event) {
			              var value = event.target.value.buffer; // get arraybuffer
			              connection.emit('data', ab2str(value));
			          });
			          return rxCharacteristic.startNotifications();
			      }).then(function() {
			          return btService.getCharacteristic(NORDIC_TX);
			      }).then(function(characteristic) {
			          txCharacteristic = characteristic;
			          log("BT> TX characteristic:" + JSON.stringify(txCharacteristic));
			      }).then(function() {
			          connection.txInProgress = false;
			          connection.isOpen = true;
			          connection.isOpening = false;
			          callback(connection);
			          connection.emit('open');
			          // if we had any writes queued, do them now
			          connection.write();
			      }).
			      catch (function(error) {
			          log('BT> ERROR: ' + error);
			          connection.close();
			      });
			      return connection;
			  };

			  // ----------------------------------------------------------
			  var connection;
			  /* convenience function... Write data, call the callback with data:
			     callbackNewline = false => if no new data received for ~0.5 sec
			     callbackNewline = true => after a newline */
			  function write(data, callback, callbackNewline) {
			      var cbTimeout;

			      function onWritten() {
			          isWriting = false;
			          if (callback) {
			              if (callbackNewline) {
			                  connection.cb = function(d) {
			                      var newLineIdx = connection.received.indexOf("\n");
			                      if (newLineIdx >= 0) {
			                          var l = connection.received.substr(0, newLineIdx);
			                          connection.received = connection.received.substr(newLineIdx + 1);
			                          connection.cb = undefined;
			                          if (cbTimeout) clearTimeout(cbTimeout);
			                          cbTimeout = undefined;
			                          if (callback) callback(l);
			                      }
			                  };
			              }
			              // wait for any received data if we have a callback...
			              var waitTime = 10;
			              var maxTime = waitTime;
			              cbTimeout = setTimeout(function timeout() {
			                  cbTimeout = undefined;
			                  if ((connection.hadData || maxTime == waitTime) && maxTime--) {
			                      cbTimeout = setTimeout(timeout, 250);
			                  } else {
			                      connection.cb = undefined;
			                      if (callback) callback(connection.received);
			                      connection.received = "";
			                  }
			                  connection.hadData = false;
			              }, 250);
			          } else connection.received = "";
			      }

			      if (connection && (connection.isOpen || connection.isOpening)) {
			          if (!connection.txInProgress) connection.received = "";
			          return connection.write(data, onWritten);
			      }

			      connection = connect(function(puck) {
			          if (!puck) {
			              connection = undefined;
			              if (callback) callback(null);
			              return;
			          }
			          connection.received = "";
			          connection.on('data', function(d) {
			              connection.received += d;
			              connection.hadData = true;
			              if (connection.cb) connection.cb(d);
			          });
			          connection.on('close', function(d) {
			              connection = undefined;
			          });
			      });
			      connection.write(data, onWritten);
			  }

			  // ----------------------------------------------------------

			  var puck = {
			      /// Are we writing debug information?
			      debug: false,
			      /// Used internally to write log information - you can replace this with your own function
			      log: function(s) {
			          if (this.debug) console.log(s)
			      },
			      /** Connect to a new device - this creates a separate
			   connection to the one `write` and `eval` use. */
			      connect: connect,
			      /// Write to Puck.js and call back when the data is written.  Creates a connection if it doesn't exist
			      write: write,
			      /// Evaluate an expression and call cb with the result. Creates a connection if it doesn't exist
			      eval: function(expr, cb) {
			          write('\x10Bluetooth.println(JSON.stringify(' + expr + '))\n', function(d) {
			              if (d !== null) cb(JSON.parse(d));
			              else cb(null);
			          }, true);
			      },
			      /// Did `write` and `eval` manage to create a connection?
			      isConnected: function() {
			          return connection !== undefined;
			      },
			      /// get the connection used by `write` and `eval`
			      getConnection: function() {
			          return connection;
			      },
			      /// Close the connection used by `write` and `eval`
			      close: function() {
			          if (connection) connection.close();
			      }
			  };
			  return puck;
			})(); 
			/* END PUCK LIBRARY */




			/* BEGIN DROPLET */

			var Droplet = (function() {
			  if (typeof navigator == "undefined") return; // not running in a web browser

			  	function puckResponse(data) {
					// console.log("Received: " + JSON.stringify(v));
					let output = document.getElementById('status');
					let state = data;

			  		var leakDetected = function() {
			  			output.innerHTML = "OMFG LEAKSSS!!!!1!!11!";
			  			sendSMS();
			  		}

			  		var allClear = function() {
						output.innerHTML = "ALL CLEAR: NO LEAK";
			  		}

					//for some reason the entire word isn't being seen a "true" so just looking for "t" and "f" as first char
					if(Droplet.ready) {
						if(state.indexOf("$true") == 0) {
							leakDetected();
						} else if(state.indexOf("$false") == 0) {
							allClear();
						} else if(state.indexOf("$reset") == 0) {
							Droplet.ready = false;
						} else {
							console.error("UNEXPECTED RESPONSE FROM PUCK: \"" + state + "\"");
						}
					}
		  		}

		  		function resetPuck(resetLED) {
		  			cmdOn = resetLED + ".write(1);";
		  			cmdOff ="LED1.write(0);LED2.write(0);LED3.write(0);"; //need to turn off all because if the button is held down too long the "on" LED will remain
		  			sendCmd = "Bluetooth.println('$reset');"+cmdOn+"setTimeout('"+cmdOff+";reset();', 1000);"
		  			return sendCmd;
		  		}

		  		function sendSMS() {
					var msg = "Droplet sensor near the Kitchen Sink has detected water! You will be notified every 15 minutes until it is dry.";

					// var f = document.createElement("form");
					// f.setAttribute('method',"post");
					// f.setAttribute('action',"submit.php");
					// f.setAttribute('id', "notifier")

					// var nodeId = document.createElement("input"); //input element, text
					// nodeId.setAttribute('type',"hidden");
					// nodeId.setAttribute('name',"nodeId");
					// nodeId.setAttribute('value', "2");

					// var status = document.createElement("input"); //input element, text
					// status.setAttribute('type',"hidden");
					// status.setAttribute('name',"status");
					// status.setAttribute('value', "h2o");

					// var msgField = document.createElement("input"); //input element, text
					// msgField.setAttribute('type',"hidden");
					// msgField.setAttribute('name',"msg");
					// msgField.setAttribute('value', encodeURI(msg));

					// f.appendChild(nodeId);
					// f.appendChild(status);
					// f.appendChild(msgField);

					//document.getElementsByTagName('body')[0].appendChild(f);
					
					data = {
						"nodeId": "2",
						"status": "h2o",
						"msg": msg
					}

					$.post("http://droplet.works/api/sms", data, function() {
						console.log("SMS sent!");
					});


		  		}

				function startPuck(callback) {
					console.log("Starting puck...");

					// console.log("\n\nCONNECTED? " + Puck.isConnected() + "\n\n");

					if(Puck.isConnected()) {
						console.log("Already connected to Puck! Resetting and closing connection...");

						let cmd = "reset();";
						Puck.write(cmd, function() {document.getElementById('status').innerHTML="";document.getElementById('go').innerHTML="START";console.log("COMMAND SENT");});
						if(connection) {
							Puck.close();
						}
						// connected = false;

					} else {

						console.log("Time to connect to puck BLE!");
						Puck.connect(function(c) {
							if (!c) {
							  alert("Couldn't connect!");
							  return;
							}
							connection = c;
							Droplet.connection = connection;

							// Handle the data we get back, and call 'puckResponse'
							// whenever we get a line
							var buf = "";
							connection.on("data", function(d) {
							  buf += d;
							  var i = buf.indexOf("\n");
							  while (i>=0) {
							    puckResponse(buf.substr(0,i));
							    buf = buf.substr(i+1);
							    i = buf.indexOf("\n");
							  }
							});

							// First, reset Puck.js and wait 1500ms
							connection.write(resetPuck("LED3")+"\n", function() {
								connection.write("NRF.on('disconnect', function() { reset(); });");
								// let cmd = "setInterval(function(){Bluetooth.println(Puck.light());},100);\n";
								let cmd = "var cnt = 0;setInterval(function(){var notify=false; var btn=BTN.read();var cap=Puck.capSense(D12,D11); if(btn) { LED1.write(1); notify=true; cnt++; if(cnt > 25) { cnt=0;LED1.write(0);"+resetPuck('LED3')+"} } else if((cap > 7000)) { LED1.write(1); notify=true; } else { LED1.write(0);};Bluetooth.println('$'+notify);},100);\n";

								setTimeout(function() {
									button = document.getElementById('go');
									connection.write(cmd, function() { button.innerHTML.className="hidden"; setTimeout("Droplet.ready = true", 1500);});
								}, 1500);
							});

						});
					}
				}

		    	var init = function() {
		    		console.log("Initializing...");
		    		var button = document.getElementById("go");
		    		// button.removeEventListener("click", closePuck);
		    		button.addEventListener("click", startPuck);
				}

				var droplet = {
					debug: false,

					ready: false,

					connected: false,

					connection: null,

					init: init,

					startPuck: startPuck,

					// closePuck: closePuck,
					
					puckResponse: puckResponse,
				}

				return droplet;
			})();

	    </script>

	    <style>
	    	.hidden {
	    		display: none;
	    	}
	    </style>

	</head>

	<body>
		<button id="go">START</button>

		<div id="status">ALL CLEAR: NO LEAK</div>

		<script>
	    	$(document).ready(function() {
				Droplet.init();
	    	});

		</script>

	</body>
</html>
