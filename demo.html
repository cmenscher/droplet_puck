
<!doctype html>
<html lang="en">
	<head>
	    <meta charset="utf-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
	        
	    <title>Droplet Demo</title>

	    <script>
			/*
			--------------------------------------------------------------------
			Puck.js BLE Interface library
			                    Copyright 2016 Gordon Williams (gw@pur3.co.uk)
			--------------------------------------------------------------------
			This Source Code Form is subject to the terms of the Mozilla Public
			License, v. 2.0. If a copy of the MPL was not distributed with this
			file, You can obtain one at http://mozilla.org/MPL/2.0/.
			--------------------------------------------------------------------
			This creates a 'Puck' object that can be used from the Web Browser.

			Simple usage:

			Puck.write("LED1.set()\n")

			Execute expression and return the result:

			Puck.eval("BTN.read()", function(d) {
			  alert(d);
			});

			Or write and wait for a result - this will return all characters,
			including echo and linefeed from the REPL so you may want to send
			`echo(0)` and use `console.log` when doing this.

			Puck.write("1+2\n", function(d) {
			  alert(d);
			});

			Or more advanced usage with control of the connection
			- allows multiple connections

			Puck.connect(function(connection) {
			  if (!connection) throw "Error!";
			  connection.on('data', function(d) { ... });
			  connection.on('close', function() { ... });
			  connection.write("1+2\n", function() {
			    connection.close();
			  });
			});

			*/
			var Puck = (function() {
			  if (typeof navigator == "undefined") return; // not running in a web browser

			  var NORDIC_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
			  var NORDIC_TX = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
			  var NORDIC_RX = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
			  var CHUNKSIZE = 16;

			  function log(s) {
			      if (puck.log) puck.log(s);
			  }

			  function ab2str(buf) {
			      return String.fromCharCode.apply(null, new Uint8Array(buf));
			  }

			  function str2ab(str) {
			      var buf = new ArrayBuffer(str.length);
			      var bufView = new Uint8Array(buf);
			      for (var i = 0, strLen = str.length; i < strLen; i++) {
			          bufView[i] = str.charCodeAt(i);
			      }
			      return buf;
			  }


			  function connect(callback) {
			      if (!navigator.bluetooth) {
			          window.alert("Web Bluetooth isn't enabled in your browser!");
			          return;
			      }

			      var connection = {
			          on: function(evt, cb) {
			              this["on" + evt] = cb;
			          },
			          emit: function(evt, data) {
			              if (this["on" + evt]) this["on" + evt](data);
			          },
			          isOpen: false,
			          isOpening: true,
			          txInProgress: false
			      };
			      var btServer = undefined;
			      var btService;
			      var connectionDisconnectCallback;
			      var txCharacteristic;
			      var rxCharacteristic;
			      var txDataQueue = [];

			      connection.close = function() {
			          connection.isOpening = false;
			          if (connection.isOpen) {
			              connection.isOpen = false;
			              connection.emit('close');
			          } else {
			              if (callback) callback(null);
			          }
			          if (btServer) {
			              btServer.disconnect();
			              btServer = undefined;
			              txCharacteristic = undefined;
			              rxCharacteristic = undefined;
			          }
			      };

			      connection.write = function(data, callback) {
			          if (data) txDataQueue.push({
			              data: data,
			              callback: callback
			          });
			          if (connection.isOpen && !connection.txInProgress) writeChunk();

			          function writeChunk() {
			              var chunk;
			              if (!txDataQueue.length) return;
			              var txItem = txDataQueue[0];
			              if (txItem.data.length <= CHUNKSIZE) {
			                  chunk = txItem.data;
			                  txItem.data = undefined;
			              } else {
			                  chunk = txItem.data.substr(0, CHUNKSIZE);
			                  txItem.data = txItem.data.substr(CHUNKSIZE);
			              }
			              connection.txInProgress = true;
			              log("BT> Sending " + JSON.stringify(chunk));
			              txCharacteristic.writeValue(str2ab(chunk)).then(function() {
			                  log("BT> Sent");
			                  if (!txItem.data) {
			                      txDataQueue.shift(); // remove this element
			                      if (txItem.callback) txItem.callback();
			                  }
			                  connection.txInProgress = false;
			                  writeChunk();
			              }).
			              catch (function(error) {
			                  log('BT> SEND ERROR: ' + error);
			                  txDataQueue = [];
			                  connection.close();
			              });
			          }
			      };

			      navigator.bluetooth.requestDevice({
			          filters: [{
			              namePrefix: 'Puck.js'
			          }, {
			              namePrefix: 'Espruino'
			          }, {
			              services: [NORDIC_SERVICE]
			          }],
			          optionalServices: [NORDIC_SERVICE]
			      }).then(function(device) {
			          log('BT>  Device Name:       ' + device.name);
			          log('BT>  Device ID:         ' + device.id);
			          // Was deprecated: Should use getPrimaryServices for this in future
			          //log('BT>  Device UUIDs:      ' + device.uuids.join('\n' + ' '.repeat(21)));
			          device.addEventListener('gattserverdisconnected', function() {
			              log("BT> Disconnected (gattserverdisconnected)");
			              connection.close();
			          });
			          return device.gatt.connect();
			      }).then(function(server) {
			          log("BT> Connected");
			          btServer = server;
			          return server.getPrimaryService(NORDIC_SERVICE);
			      }).then(function(service) {
			          log("BT> Got service");
			          btService = service;
			          return btService.getCharacteristic(NORDIC_RX);
			      }).then(function(characteristic) {
			          rxCharacteristic = characteristic;
			          log("BT> RX characteristic:" + JSON.stringify(rxCharacteristic));
			          rxCharacteristic.addEventListener('characteristicvaluechanged', function(event) {
			              var value = event.target.value.buffer; // get arraybuffer
			              connection.emit('data', ab2str(value));
			          });
			          return rxCharacteristic.startNotifications();
			      }).then(function() {
			          return btService.getCharacteristic(NORDIC_TX);
			      }).then(function(characteristic) {
			          txCharacteristic = characteristic;
			          log("BT> TX characteristic:" + JSON.stringify(txCharacteristic));
			      }).then(function() {
			          connection.txInProgress = false;
			          connection.isOpen = true;
			          connection.isOpening = false;
			          callback(connection);
			          connection.emit('open');
			          // if we had any writes queued, do them now
			          connection.write();
			      }).
			      catch (function(error) {
			          log('BT> ERROR: ' + error);
			          connection.close();
			      });
			      return connection;
			  };

			  // ----------------------------------------------------------
			  var connection;
			  /* convenience function... Write data, call the callback with data:
			     callbackNewline = false => if no new data received for ~0.5 sec
			     callbackNewline = true => after a newline */
			  function write(data, callback, callbackNewline) {
			      var cbTimeout;

			      function onWritten() {
			          isWriting = false;
			          if (callback) {
			              if (callbackNewline) {
			                  connection.cb = function(d) {
			                      var newLineIdx = connection.received.indexOf("\n");
			                      if (newLineIdx >= 0) {
			                          var l = connection.received.substr(0, newLineIdx);
			                          connection.received = connection.received.substr(newLineIdx + 1);
			                          connection.cb = undefined;
			                          if (cbTimeout) clearTimeout(cbTimeout);
			                          cbTimeout = undefined;
			                          if (callback) callback(l);
			                      }
			                  };
			              }
			              // wait for any received data if we have a callback...
			              var waitTime = 10;
			              var maxTime = waitTime;
			              cbTimeout = setTimeout(function timeout() {
			                  cbTimeout = undefined;
			                  if ((connection.hadData || maxTime == waitTime) && maxTime--) {
			                      cbTimeout = setTimeout(timeout, 250);
			                  } else {
			                      connection.cb = undefined;
			                      if (callback) callback(connection.received);
			                      connection.received = "";
			                  }
			                  connection.hadData = false;
			              }, 250);
			          } else connection.received = "";
			      }

			      if (connection && (connection.isOpen || connection.isOpening)) {
			          if (!connection.txInProgress) connection.received = "";
			          return connection.write(data, onWritten);
			      }

			      connection = connect(function(puck) {
			          if (!puck) {
			              connection = undefined;
			              if (callback) callback(null);
			              return;
			          }
			          connection.received = "";
			          connection.on('data', function(d) {
			              connection.received += d;
			              connection.hadData = true;
			              if (connection.cb) connection.cb(d);
			          });
			          connection.on('close', function(d) {
			              connection = undefined;
			          });
			      });
			      connection.write(data, onWritten);
			  }

			  // ----------------------------------------------------------

			  var puck = {
			      /// Are we writing debug information?
			      debug: false,
			      /// Used internally to write log information - you can replace this with your own function
			      log: function(s) {
			          if (this.debug) console.log(s)
			      },
			      /** Connect to a new device - this creates a separate
			   connection to the one `write` and `eval` use. */
			      connect: connect,
			      /// Write to Puck.js and call back when the data is written.  Creates a connection if it doesn't exist
			      write: write,
			      /// Evaluate an expression and call cb with the result. Creates a connection if it doesn't exist
			      eval: function(expr, cb) {
			          write('\x10Bluetooth.println(JSON.stringify(' + expr + '))\n', function(d) {
			              if (d !== null) cb(JSON.parse(d));
			              else cb(null);
			          }, true);
			      },
			      /// Did `write` and `eval` manage to create a connection?
			      isConnected: function() {
			          return connection !== undefined;
			      },
			      /// get the connection used by `write` and `eval`
			      getConnection: function() {
			          return connection;
			      },
			      /// Close the connection used by `write` and `eval`
			      close: function() {
			          if (connection) connection.close();
			      }
			  };
			  return puck;
			})(); 
			/* END PUCK LIBRARY */


			/* BEGIN DROPLET */
			function doSomething() {

				// Called when we get a line of data from the puck
				function puckResponse(v) {
				  // console.log("Received: " + JSON.stringify(v));
				  let output = document.getElementById('status');
				  let state = v;

				  //for some reason the entire word isn't being seen a "true" so just looking for "t" and "f" as first char
				  if(state.indexOf("true") == 0) {
				  	output.innerHTML = "OMFG LEAKSSS!!!!1!!11!";
				  } else if(state.indexOf("false") == 0) {
				  	output.innerHTML = "ALL CLEAR: NO LEAK";
				  } else {
				  	console.log(state);
				  }
				}


	   			// var connection;
				// if (connection) {
				// 	connection.close();
				// 	connection = undefined;
				// } else {
				// 	document.getElementById('go').innerHTML="CONNECTING...";
				// }

				console.log("\n\nCONNECTED? " + Puck.isConnected() + "\n\n");

				if(Puck.isConnected()) {
					console.log("Already connected to Puck! Resetting and closing connection...");

					let cmd = "reset();";
					Puck.write(cmd, function() {document.getElementById('status').innerHTML="";document.getElementById('go').innerHTML="START";console.log("COMMAND SENT");});
					if(connection) {
						Puck.close();
					}
					// connected = false;

				} else {

					console.log("Time to connect to puck BLE!");
					Puck.connect(function(c) {
						if (!c) {
						  alert("Couldn't connect!");
						  return;
						}
						connection = c;

						// set global variable
						// connected = true;
						
						// Handle the data we get back, and call 'puckResponse'
						// whenever we get a line
						var buf = "";
						connection.on("data", function(d) {
						  buf += d;
						  var i = buf.indexOf("\n");
						  while (i>=0) {
						    puckResponse(buf.substr(0,i));
						    buf = buf.substr(i+1);
						    i = buf.indexOf("\n");
						  }
						});

						// First, reset Puck.js and wait 1500ms
						connection.write("reset();\n", function() {
							connection.write("NRF.on('disconnect', function() { reset(); });");
							// let cmd = "setInterval(function(){Bluetooth.println(Puck.light());},100);\n";
							let cmd = "Bluetooth.println('Ready......FIGHT!');setInterval(function(){var notify=false; var btn=BTN.read();var cap=Puck.capSense(D12,D11); if(btn || (cap > 7000)) { LED1.write(1); notify=true; } else { LED1.write(0);};Bluetooth.println(notify);},100);\n";

							setTimeout(function() {
								// Now tell it to write data on the current light level to Bluetooth
								// 10 times a second
								connection.write(cmd, function() { document.getElementById('go').className="hidden";console.log("COMMAND SENT");});
							}, 1500);
						});

					});

				}
			}

	    	var init = function() {
	    		var button = document.getElementById("go");
	    		button.addEventListener("click", doSomething);
			}

			// global connected flag (needs a better solution)
			// var connected = false;
	    </script>

	    <style>
	    	.hidden {
	    		display: none;
	    	}
	    </style>

	</head>

	<body>
		<button id="go">START</button>

		<div id="status">ALL CLEAR: NO LEAK</div>

		<script>init();</script>
	</body>
</html>
